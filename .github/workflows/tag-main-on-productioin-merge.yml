name: "Tag main on production merge"

on:
  pull_request:
    types: [closed]
    branches:
      - production

permissions:
  contents: write
  pull-requests: read

jobs:
  tag-main:
    name: Create semantic tag on main when PR -> production is merged
    runs-on: ubuntu-latest
    if: github.event.pull_request.merged == true
    steps:
      - name: Create a semver tag on main
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const pr = context.payload.pull_request;

            if (!pr || !pr.merged) {
              core.info('Pull request not merged - exiting.');
              return;
            }

            const mainBranch = 'main';
            // Get tip of main
            const mainResp = await github.rest.repos.getBranch({ owner, repo, branch: mainBranch });
            const mainSha = mainResp.data.commit.sha;

            // List tags (first page: up to 100). If your repo has >100 tags, we could page.
            const tagsResp = await github.rest.repos.listTags({ owner, repo, per_page: 100 });
            const allTagNames = tagsResp.data.map(t => t.name);

            // Filter tags that look like vX.Y.Z
            const semverTags = allTagNames.filter(n => /^v\d+\.\d+\.\d+$/.test(n));

            function parseSemver(name) {
              const m = name.match(/^v(\d+)\.(\d+)\.(\d+)$/);
              return m ? [parseInt(m[1],10), parseInt(m[2],10), parseInt(m[3],10)] : null;
            }

            let nextTag;
            if (semverTags.length === 0) {
              nextTag = 'v0.1.0';
            } else {
              semverTags.sort((a,b) => {
                const A = parseSemver(a), B = parseSemver(b);
                for (let i = 0; i < 3; i++) {
                  if (A[i] !== B[i]) return A[i] - B[i];
                }
                return 0;
              });
              const latest = semverTags[semverTags.length - 1];
              const parts = parseSemver(latest);
              parts[2] = parts[2] + 1; // bump patch
              nextTag = `v${parts[0]}.${parts[1]}.${parts[2]}`;
            }

            // Avoid collisions (increment patch until unused)
            let candidate = nextTag;
            let bump = 0;
            while (true) {
              try {
                await github.rest.git.getRef({ owner, repo, ref: `tags/${candidate}` });
                // exists, bump patch
                bump++;
                const base = nextTag.match(/^v(\d+)\.(\d+)\.(\d+)$/);
                const major = parseInt(base[1],10);
                const minor = parseInt(base[2],10);
                const patch = parseInt(base[3],10) + bump;
                candidate = `v${major}.${minor}.${patch}`;
              } catch (err) {
                if (err.status === 404) break;
                throw err;
              }
            }

            const tagName = candidate;
            const tagMessage = `Release ${tagName} - created when PR #${pr.number} was merged into production by @${pr.user.login}`;

            // Create an annotated tag object pointing at mainSha
            const tagObj = await github.rest.git.createTag({
              owner,
              repo,
              tag: tagName,
              message: tagMessage,
              object: mainSha,
              type: 'commit',
              tagger: {
                name: pr.user.login || 'github-actions',
                email: pr.user.email || `${pr.user.login}@users.noreply.github.com`,
                date: new Date().toISOString()
              }
            });

            // Create the ref refs/tags/<tagName> pointing to the tag object
            await github.rest.git.createRef({
              owner,
              repo,
              ref: `refs/tags/${tagName}`,
              sha: tagObj.data.sha
            });

            core.info(`Created tag ${tagName} at ${mainSha}`);